Урок 8
Немного об SQL
SQL (Structured Query Language) — это стандартный язык для работы с реляционными базами данных. Он позволяет выполнять различные операции, такие как создание, изменение, удаление и извлечение данных.

Основные команды SQL:
SELECT: Извлечение данных из базы данных.
INSERT: Добавление новых данных в таблицу.
UPDATE: Обновление существующих данных в таблице.
DELETE: Удаление данных из таблицы.
CREATE: Создание новых таблиц или баз данных.
ALTER: Изменение структуры существующей таблицы.
DROP: Удаление таблицы или базы данных.
Примеры использования:
SELECT: SELECT * FROM users;
INSERT: INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');
UPDATE: UPDATE users SET email = 'newemail@example.com' WHERE name = 'John Doe';
DELETE: DELETE FROM users WHERE name = 'John Doe'; SQL является мощным инструментом для управления данными и используется в различных системах управления базами данных (СУБД), таких как PostgreSQL, MySQL, Oracle и другие.
commit: Урок 8: немного об SQL

Основные возможности pgAdmin: Управление базой данных и визуализация
pgAdmin — это мощный инструмент для управления базами данных PostgreSQL, который предоставляет широкий спектр возможностей для администрирования и визуализации данных.

Основные возможности:
Управление базой данных: Создание, изменение и удаление баз данных, таблиц, индексов, представлений и других объектов.
Визуализация данных: Графическое представление структуры базы данных, визуализация запросов и результатов выполнения.
Мониторинг и управление производительностью: Мониторинг и управление производительностью базы данных.
Управление пользователями и ролями: Настройка прав доступа и управление пользователями.
Примеры использования:
Создание таблицы: Используйте графический интерфейс для создания новых таблиц.
Выполнение запросов: Используйте вкладку "Query Tool" для выполнения SQL-запросов.
Визуализация данных: Построение диаграмм и отчетов на основе данных. pgAdmin позволяет эффективно управлять базами данных PostgreSQL, обеспечивая удобный и интуитивно понятный интерфейс для выполнения различных задач.
commit: Урок 8: основные возможности pgAdmin: Управление базой данных и визуализация

Создание таблиц: Структура и параметры таблиц
Создание таблиц в PostgreSQL — это процесс определения структуры данных, которые будут храниться в базе данных. Вот пошаговое руководство по созданию таблиц:

Шаги создания таблицы:
Откройте pgAdmin и подключитесь к серверу.
Выберите базу данных.
Создайте новую таблицу:
Щелкните правой кнопкой мыши на базе данных и выберите "Create" -> "Table".
Введите имя таблицы и выберите схему (по умолчанию public).
Определите столбцы:
В разделе "Columns" добавьте столбцы, указав их имена, типы данных и ограничения (например, NOT NULL, UNIQUE).
Сохраните таблицу:
Нажмите "Save" для создания таблицы.
Параметры таблиц:
Типы данных: Определяют, какие данные могут храниться в столбцах (например, INTEGER, VARCHAR, DATE).
Ограничения: Ограничения, такие как NOT NULL, UNIQUE, CHECK, которые обеспечивают целостность данных.
Индексы: Структуры, которые ускоряют поиск данных.
Внешние ключи: Ссылки на первичные ключи в других таблицах, которые устанавливают связи между таблицами.
Пример создания таблицы:
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL
);

**commit: `Урок 8: cоздание таблиц: Структура и параметры таблиц`**

### Типы данных: Основные типы данных `PostgreSQL`
`PostgreSQL` поддерживает широкий спектр типов данных, которые могут быть использованы для хранения различных видов информации. Вот список основных типов данных и их применения:

#### Числовые типы:
- **INTEGER**: Целое число. Используется для хранения целых чисел, таких как идентификаторы, количества и т.д.
- **BIGINT**: Большое целое число. Используется для хранения очень больших целых чисел.
- **SMALLINT**: Малое целое число. Используется для хранения небольших целых чисел.
- **NUMERIC (или DECIMAL)**: Число с фиксированной точностью. Используется для хранения денежных сумм, процентов и других точных чисел.
- **REAL**: Число с плавающей точкой одинарной точности. Используется для хранения чисел с плавающей точкой, где точность не критична.
- **DOUBLE PRECISION**: Число с плавающей точкой двойной точности. Используется для хранения чисел с плавающей точкой, где требуется высокая точность.
- **SERIAL**: Автоинкрементное целое число. Используется для создания уникальных идентификаторов.

#### Строковые типы:
- **CHAR(n)**: Фиксированная длина строки. Используется для хранения строк фиксированной длины.
- **VARCHAR(n)**: Переменная длина строки. Используется для хранения строк переменной длины.
- **TEXT**: Строка переменной длины без ограничения. Используется для хранения больших объемов текста.

#### Дата и время:
- **DATE**: Дата. Используется для хранения дат без времени.
- **TIME**: Время. Используется для хранения времени без даты.
- **TIMESTAMP**: Дата и время. Используется для хранения даты и времени.
- **TIMESTAMPTZ**: Дата и время с часовым поясом. Используется для хранения даты и времени с учетом часового пояса.
- **INTERVAL**: Интервал времени. Используется для хранения промежутков времени.

#### Логические типы:
- **BOOLEAN**: Логическое значение. Используется для хранения значений `TRUE` или `FALSE`.

#### Двоичные типы:
- **BYTEA**: Двоичные данные. Используется для хранения двоичных данных, таких как изображения, файлы и т.д.

#### Специальные типы:
- **UUID**: Универсальный уникальный идентификатор. Используется для хранения уникальных идентификаторов.
- **JSON**: JSON данные. Используется для хранения данных в формате JSON.
- **JSONB**: Двоичный JSON. Используется для хранения данных в формате JSON с более эффективным хранением и поиском.
- **ARRAY**: Массив. Используется для хранения массивов данных.
- **ENUM**: Перечисление. Используется для хранения значений из заранее определенного набора.

**commit: `Урок 8: типы данных: Основные типы данных PostgreSQL`**

### Проектирование моделей баз данных: Оптимизация структуры базы данных для типичных задач
Проектирование базы данных — это процесс создания структуры базы данных, которая эффективно хранит, извлекает и управляет данными. Основные шаги проектирования базы данных включают:
#### Этапы проектирования базы данных:
1. **Сбор требований**: Определение, какие данные нужно хранить и как они будут использоваться.
2. **Концептуальное проектирование**: Создание ER-диаграмм (Entity-Relationship) для визуализации сущностей и их связей.
3. **Логическое проектирование**: Определение таблиц, столбцов, типов данных и ограничений.
4. **Физическое проектирование**: Оптимизация структуры базы данных для конкретной СУБД, включая индексы, партиционирование и т.д.
5. **Реализация**: Создание базы данных и таблиц в СУБД.
#### Нормальные формы:
Нормальные формы помогают организовать данные в базе данных таким образом, чтобы избежать избыточности и обеспечить целостность данных.
1. **Первая нормальная форма (1NF)**:
   - Каждая таблица должна иметь уникальный первичный ключ.
   - Каждый столбец должен содержать атомарные значения (не должно быть массивов или списков в одном столбце).
2. **Вторая нормальная форма (2NF)**:
   - Таблица должна быть в 1NF.
   - Все неключевые атрибуты должны полностью зависеть от первичного ключа.
3. **Третья нормальная форма (3NF)**:
   - Таблица должна быть в 2NF.
   - Все атрибуты должны зависеть только от первичного ключа (не должно быть транзитивных зависимостей).

#### Индексы:
Индексы — это специальные структуры данных, которые ускоряют поиск и сортировку данных в базе данных. Они работают аналогично указателю в книге, который позволяет быстро найти нужную страницу без необходимости просматривать всю книгу.
- **Аналогия**: Представьте себе библиотеку с тысячами книг. Без каталога (индекса) вам придется просматривать каждую книгу, чтобы найти нужную. Каталог (индекс) позволяет быстро найти нужную книгу по автору, названию или теме.
- **Для чего нужны**:
  - **Ускорение поиска**: Индексы значительно ускоряют выполнение запросов, особенно в больших таблицах.
  - **Оптимизация сортировки**: Индексы помогают быстро сортировать данные по определенным столбцам.
  - **Уникальность данных**: Индексы могут обеспечивать уникальность значений в столбцах, что помогает избежать дублирования данных.

#### Пример создания базы данных:
```sql
-- Создание таблицы Category
CREATE TABLE category (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор категории
    name VARCHAR(255) UNIQUE NOT NULL -- Уникальное имя категории
);
-- Создание таблицы Tag
CREATE TABLE tag (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор тега
    name VARCHAR(255) UNIQUE NOT NULL -- Уникальное имя тега
);
-- Создание таблицы Article
CREATE TABLE article (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор статьи
    title VARCHAR(255) NOT NULL, -- Заголовок статьи
    content TEXT NOT NULL, -- Содержание статьи
    publication_date TIMESTAMPTZ DEFAULT NOW(), -- Дата публикации статьи
    views INTEGER DEFAULT 0, -- Количество просмотров статьи
    category_id INTEGER NOT NULL DEFAULT 1, -- Идентификатор категории статьи
    slug VARCHAR(255) UNIQUE, -- Уникальный slug статьи
    is_active BOOLEAN DEFAULT TRUE, -- Статус активности статьи
    FOREIGN KEY (category_id) REFERENCES category(id) ON DELETE CASCADE -- Внешний ключ на таблицу Category
);
-- Создание таблицы для связи Article и Tag
CREATE TABLE article_tag (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор связи
    article_id INTEGER NOT NULL, -- Идентификатор статьи
    tag_id INTEGER NOT NULL, -- Идентификатор тега
    FOREIGN KEY (article_id) REFERENCES article(id) ON DELETE CASCADE, -- Внешний ключ на таблицу Article
    FOREIGN KEY (tag_id) REFERENCES tag(id) ON DELETE CASCADE -- Внешний ключ на таблицу Tag
);
-- Создание индексов для ускорения поиска
CREATE INDEX idx_article_title ON article (title); -- Индекс для поиска по заголовку статьи
CREATE INDEX idx_article_slug ON article (slug); -- Индекс для поиска по slug статьи
-- Создание триггера для автоматического заполнения slug
CREATE OR REPLACE FUNCTION update_slug() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.slug IS NULL THEN
        NEW.slug := slugify(NEW.title); -- Функция slugify должна быть определена заранее
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_slug
BEFORE INSERT OR UPDATE ON article
FOR EACH ROW
EXECUTE FUNCTION update_slug();
commit: Урок 8: проектирование моделей баз данных: Оптимизация структуры базы данных для типичных задач

Проектирование моделей баз данных: Оптимизация структуры базы данных для типичных задач
Проектирование базы данных — это процесс создания структуры базы данных, которая эффективно хранит, извлекает и управляет данными. Основные шаги проектирования базы данных включают:

Этапы проектирования базы данных:
Сбор требований: Определение, какие данные нужно хранить и как они будут использоваться.
Концептуальное проектирование: Создание ER-диаграмм (Entity-Relationship) для визуализации сущностей и их связей.
Логическое проектирование: Определение таблиц, столбцов, типов данных и ограничений.
Физическое проектирование: Оптимизация структуры базы данных для конкретной СУБД, включая индексы, партиционирование и т.д.
Реализация: Создание базы данных и таблиц в СУБД.
Нормальные формы:
Нормальные формы помогают организовать данные в базе данных таким образом, чтобы избежать избыточности и обеспечить целостность данных.

Первая нормальная форма (1NF):
Каждая таблица должна иметь уникальный первичный ключ.
Каждый столбец должен содержать атомарные значения (не должно быть массивов или списков в одном столбце).
Вторая нормальная форма (2NF):
Таблица должна быть в 1NF.
Все неключевые атрибуты должны полностью зависеть от первичного ключа.
Третья нормальная форма (3NF):
Таблица должна быть в 2NF.
Все атрибуты должны зависеть только от первичного ключа (не должно быть транзитивных зависимостей).
Индексы:
Индексы — это специальные структуры данных, которые ускоряют поиск и сортировку данных в базе данных. Они работают аналогично указателю в книге, который позволяет быстро найти нужную страницу без необходимости просматривать всю книгу.

Аналогия: Представьте себе библиотеку с тысячами книг. Без каталога (индекса) вам придется просматривать каждую книгу, чтобы найти нужную. Каталог (индекс) позволяет быстро найти нужную книгу по автору, названию или теме.
Для чего нужны:
Ускорение поиска: Индексы значительно ускоряют выполнение запросов, особенно в больших таблицах.
Оптимизация сортировки: Индексы помогают быстро сортировать данные по определенным столбцам.
Уникальность данных: Индексы могут обеспечивать уникальность значений в столбцах, что помогает избежать дублирования данных.
Пример создания базы данных:
-- Создание таблицы Category
CREATE TABLE category (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор категории
    name VARCHAR(255) UNIQUE NOT NULL -- Уникальное имя категории
);
-- Создание таблицы Tag
CREATE TABLE tag (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор тега
    name VARCHAR(255) UNIQUE NOT NULL -- Уникальное имя тега
);
-- Создание таблицы Article
CREATE TABLE article (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор статьи
    title VARCHAR(255) NOT NULL, -- Заголовок статьи
    content TEXT NOT NULL, -- Содержание статьи
    publication_date TIMESTAMPTZ DEFAULT NOW(), -- Дата публикации статьи
    views INTEGER DEFAULT 0, -- Количество просмотров статьи
    category_id INTEGER NOT NULL DEFAULT 1, -- Идентификатор категории статьи
    slug VARCHAR(255) UNIQUE, -- Уникальный slug статьи
    is_active BOOLEAN DEFAULT TRUE, -- Статус активности статьи
    FOREIGN KEY (category_id) REFERENCES category(id) ON DELETE CASCADE -- Внешний ключ на таблицу Category
);
-- Создание таблицы для связи Article и Tag
CREATE TABLE article_tag (
    id SERIAL PRIMARY KEY, -- Уникальный идентификатор связи
    article_id INTEGER NOT NULL, -- Идентификатор статьи
    tag_id INTEGER NOT NULL, -- Идентификатор тега
    FOREIGN KEY (article_id) REFERENCES article(id) ON DELETE CASCADE, -- Внешний ключ на таблицу Article
    FOREIGN KEY (tag_id) REFERENCES tag(id) ON DELETE CASCADE -- Внешний ключ на таблицу Tag
);
-- Создание индексов для ускорения поиска
CREATE INDEX idx_article_title ON article (title); -- Индекс для поиска по заголовку статьи
CREATE INDEX idx_article_slug ON article (slug); -- Индекс для поиска по slug статьи
-- Создание триггера для автоматического заполнения slug
CREATE OR REPLACE FUNCTION update_slug() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.slug IS NULL THEN
        NEW.slug := slugify(NEW.title); -- Функция slugify должна быть определена заранее
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE TRIGGER trigger_update_slug
BEFORE INSERT OR UPDATE ON article
FOR EACH ROW
EXECUTE FUNCTION update_slug();
commit: Урок 8: проектирование моделей баз данных: Оптимизация структуры базы данных для типичных задач

Решение практики с 8 урока
# Задача 1: Найти все статьи, которые были опубликованы после 31 октября 2023 года.
# Фильтрация статей по дате публикации, которая больше 31 октября 2023 года.
articles = Article.objects.filter(publication_date__gt=timezone.datetime(2023, 10, 31))
print(articles)

# Задача 2: Найти все статьи, которые принадлежат категории "Образование" и имеют тег "Инновации".
# Создание объектов Q для условий фильтрации для категории "Образование" и тега "Инновации".
category_q = Q(category__name='Образование')
tag_q = Q(tags__name='Инновации')
# Комбинирование условий с использованием логического оператора AND.
articles = Article.objects.filter(category_q & tag_q)
print(articles)

# Задача 3: Найти все статьи, которые не принадлежат категории "Культура".
# Создание объекта Q для условия фильтрации для категории "Культура".
category_q = Q(category__name='Культура')
# Использование логического оператора NOT для инвертирования условия.
articles = Article.objects.filter(~category_q)
print(articles)

# Задача 4: Найти все статьи, которые принадлежат категории "Здоровье" или "Образование" и имеют тег "Исследования".
# Создание объектов Q для условий фильтрации для категорий "Здоровье" и "Образование" и тега "Исследования".
category_q1 = Q(category__name='Здоровье')
category_q2 = Q(category__name='Образование')
tag_q = Q(tags__name='Исследования')
# Комбинирование условий с использованием логических операторов OR и AND.
articles = Article.objects.filter((category_q1 | category_q2) & tag_q)
print(articles)

# Задача 5: Увеличить количество просмотров всех статей на 5.
# Использование класса F для создания выражения, которое ссылается на поле views.
# Обновление всех записей в таблице Article, увеличивая количество просмотров на 5.
Article.objects.update(views=F('views') + 5)

# Задача 6: Аннотировать все статьи с константным значением `is_featured` равным `False`.
# Использование метода annotate() для добавления нового поля is_featured со значением False ко всем статьям.
articles = Article.objects.annotate(is_featured=Value(False))
for article in articles:
    print(article.is_featured)  # Выведет False для всех статей

# Задача 7: Найти все статьи, которые были опубликованы в 2023 году.
# Фильтрация статей по году публикации, который равен 2023.
articles = Article.objects.filter(publication_date__year=2023)
print(articles)

# Задача 8: Найти все статьи, которые принадлежат категории "Технологии" и имеют тег "Инновации".
# Создание объектов Q для условий фильтрации для категории "Технологии" и тега "Инновации".
category_q = Q(category__name='Технологии')
tag_q = Q(tags__name='Инновации')
# Комбинирование условий с использованием логического оператора AND.
articles = Article.objects.filter(category_q & tag_q)
print(articles)

# Задача 9: Подсчитать количество статей в каждой категории.
# Использование метода values() для выбора поля category__name, по которому будем группировать данные.
# Использование метода annotate() для добавления нового поля count, которое представляет собой количество статей в каждой категории.
category_counts = Article.objects.values('category__name').annotate(count=Count('id'))
for category in category_counts:
    print(f"Category: {category['category__name']}, Count: {category['count']}")

# Задача 10: Подсчитать суммарное количество просмотров всех статей.
# Использование метода aggregate() для выполнения агрегатной операции суммирования над полем views.
total_views = Article.objects.aggregate(total_views=Sum('views'))
print(f"Total Views: {total_views['total_views']}")

# Задача 11: Найти статьи, у которых количество просмотров больше 150.
# Фильтрация статей по количеству просмотров, которое больше 150.
articles = Article.objects.filter(views__gt=150)
print(articles)

# Задача 12: Найти статьи, у которых количество просмотров меньше или равно 200.
# Фильтрация статей по количеству просмотров, которое меньше или равно 200.
articles = Article.objects.filter(views__lte=200)
print(articles)
commit: Урок 8: Решение практики с 7 урока