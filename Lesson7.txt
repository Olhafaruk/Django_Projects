Урок 7
Очистка базы данных
python manage.py flush

Загрузка новых данных
python manage.py loaddata articles_4.json

commit: Урок 7: Подготовка данных

Класс Q
# Пример 1: Простое использование Q
# Создаем объекты Q для условий
category_q = Q(category__name='Технологии')
tag_q = Q(tags__name='Инновации')
# Комбинируем условия с помощью логического оператора OR
articles = Article.objects.filter(category_q | tag_q)

# Пример 2: Комбинирование условий с AND и OR
# Создаем объекты Q для условий
category_q = Q(category__name='Наука')
tag_q1 = Q(tags__name='Исследования')
tag_q2 = Q(tags__name='Инновации')
# Комбинируем условия с помощью логических операторов
articles = Article.objects.filter(category_q & (tag_q1 | tag_q2))

# Пример 3: Использование NOT
# Создаем объект Q для условия
category_q = Q(category__name='Спорт')
# Используем логический оператор NOT
articles = Article.objects.filter(~category_q)

# Пример 4: Комбинирование нескольких условий
# Создаем объекты Q для условий
category_q1 = Q(category__name='Технологии')
category_q2 = Q(category__name='Наука')
tag_q1 = Q(tags__name='Инновации')
tag_q2 = Q(tags__name='Исследования')
# Комбинируем условия с помощью логических операторов
articles = Article.objects.filter((category_q1 | category_q2) & (tag_q1 | tag_q2))
commit: Урок 7: Класс Q

Методы exists() и count(): Проверка наличия данных и подсчёт записей
# Пример 1: Проверка наличия статей в категории "Технологии"
# Проверяем наличие статей в категории "Технологии"
exists = Article.objects.filter(category__name='Технологии').exists()
print(exists)  # Выведет True или False

# Пример 2: Подсчет количества статей в категории "Наука"
# Подсчитываем количество статей в категории "Наука"
count = Article.objects.filter(category__name='Наука').count()
print(count)  # Выведет количество статей

# Пример 3: Проверка наличия статей с тегом "Инновации" или "Исследования"
# Создаем объекты Q для условий
tag_q1 = Q(tags__name='Инновации')
tag_q2 = Q(tags__name='Исследования')
# Проверяем наличие статей с тегами "Инновации" или "Исследования"
exists = Article.objects.filter(tag_q1 | tag_q2).exists()
print(exists)  # Выведет True или False

# Пример 4: Подсчет количества статей в категории "Технологии" или "Наука"
# Создаем объекты Q для условий
category_q1 = Q(category__name='Технологии')
category_q2 = Q(category__name='Наука')
# Подсчитываем количество статей в категории "Технологии" или "Наука"
count = Article.objects.filter(category_q1 | category_q2).count()
print(count)  # Выведет количество статей
commit: Урок 7: Методы exists() и count()

Класс F, Value и метод annotate(): Выполнение операций с полями внутри запросов
# Пример 1: Увеличение количества просмотров статьи
# Найдем статью по slug и увеличим количество просмотров на 1
Article.objects.filter(slug='17-kroty-otkryli-restoran').update(views=F('views') + 1)

# Пример 2: Аннотация статей с константным значением
# Аннотируем все статьи с константным значением is_featured
articles = Article.objects.annotate(is_featured=Value(True))
for article in articles:
    print(article.is_featured)  # Выведет True для всех статей

# Пример 3: Аннотация статей с количеством просмотров, увеличенным на 10
# Аннотируем все статьи с количеством просмотров, увеличенным на 10
articles = Article.objects.annotate(increased_views=F('views') + 10)
for article in articles:
    print(article.increased_views)  # Выведет количество просмотров, увеличенное на 10
commit: Урок 7: Класс F, Value и метод annotate()

Агрегация данных: Использование Count, Sum, Avg, Max, Min и метода values()
# Пример 1: Подсчет количества статей в каждой категории
# Подсчитываем количество статей в каждой категории
category_counts = Article.objects.values('category__name').annotate(count=Count('id'))
for category in category_counts:
    print(f"Category: {category['category__name']}, Count: {category['count']}")

# Пример 2: Суммирование количества просмотров всех статей
# Подсчитываем суммарное количество просмотров всех статей
total_views = Article.objects.aggregate(total_views=Sum('views'))
print(f"Total Views: {total_views['total_views']}")

# Пример 3: Вычисление среднего количества просмотров статей
# Вычисляем среднее количество просмотров статей
average_views = Article.objects.aggregate(average_views=Avg('views'))
print(f"Average Views: {average_views['average_views']}")

# Пример 4: Нахождение максимального и минимального количества просмотров статей
# Находим максимальное и минимальное количество просмотров статей
max_views = Article.objects.aggregate(max_views=Max('views'))
min_views = Article.objects.aggregate(min_views=Min('views'))
print(f"Max Views: {max_views['max_views']}")
print(f"Min Views: {min_views['min_views']}")

# Пример 5: Подсчет количества статей в каждой категории с использованием values() и annotate()
# Подсчитываем количество статей в каждой категории
category_counts = Article.objects.values('category__name').annotate(count=Count('id'))
for category in category_counts:
    print(f"Category: {category['category__name']}, Count: {category['count']}")
commit: Урок 7: Агрегация данных

установили отладочную панель Django (pip install django-debug-toolbar) и настроили её
убедились в том, что наше приложение генерирует слишком много запросов
commit: Урок 7: Установили отладочную панель Django

включили жадную загрузку и снизили количество запросов до 4
articles = Article.objects.select_related('category').prefetch_related('tags')
prefetch_related и select_related
prefetch_related и select_related — это методы оптимизации запросов в Django ORM, которые используются для уменьшения количества запросов к базе данных и повышения производительности при работе с моделями, связанными через внешние ключи или отношения "многие ко многим".

select_related
select_related используется для выполнения запросов к моделям, связанных через внешние ключи (ForeignKey). Это позволяет получить все необходимые данные за один запрос, вместо того чтобы выполнять отдельные запросы для каждого связанного объекта.

prefetch_related
prefetch_related используется для выполнения отдельных запросов для получения связанных объектов, но делает это более эффективно, чем выполнение отдельных запросов для каждого связанного объекта. Это особенно полезно для отношений "многие ко многим" (ManyToManyField) и обратных отношений (reverse ForeignKey).

Основные различия
Тип отношений:
select_related работает с однозначными отношениями (ForeignKey и OneToOneField).
prefetch_related работает с отношениями "многие ко многим" (ManyToManyField) и обратными отношениями (reverse ForeignKey).
Механизм работы:
select_related использует SQL-объединения (JOIN), что может быть более эффективно для небольших наборов данных.
prefetch_related выполняет отдельные запросы для получения связанных объектов, что может быть более эффективно для больших наборов данных или сложных отношений.
Производительность:
select_related может быть быстрее для небольших наборов данных, так как выполняет меньше запросов.
prefetch_related может быть более эффективен для больших наборов данных, так как выполняет отдельные запросы для связанных объектов, что может уменьшить нагрузку на базу данных.
Ленивая загрузка (Lazy Loading) и Жадная загрузка (Eager Loading)
В Django ORM ленивая загрузка (lazy loading) и жадная загрузка (eager loading) — это два подхода к загрузке связанных данных, которые могут существенно повлиять на производительность вашего приложения. Выбор между ними зависит от конкретных требований и сценариев использования.

Ленивая загрузка (Lazy Loading)
Ленивая загрузка — это подход, при котором связанные данные загружаются только тогда, когда они действительно нужны. Это поведение по умолчанию в Django ORM. Преимущества:

Экономия ресурсов: Данные загружаются только при необходимости, что может снизить нагрузку на базу данных и уменьшить использование памяти.
Простота: Не требует дополнительных настроек или оптимизаций. Недостатки:
N+1 проблема: Может привести к большому количеству запросов к базе данных, если связанные данные загружаются в цикле. Пример:
articles = Article.objects.all()
for article in articles:
    print(article.title)  # Каждый раз выполняется отдельный запрос для получения статьи
Жадная загрузка (Eager Loading)
Жадная загрузка — это подход, при котором связанные данные загружаются заранее, в один или несколько запросов. В Django это достигается с помощью методов select_related и prefetch_related. Преимущества:

Снижение количества запросов: Уменьшает количество запросов к базе данных, что может значительно повысить производительность.
Оптимизация: Позволяет более эффективно использовать ресурсы базы данных и памяти. Недостатки:
Избыточность: Может загружать данные, которые в итоге не понадобятся, что может привести к избыточному использованию памяти.
Сложность: Требует дополнительных настроек и оптимизаций. Пример с select_related и prefetch_related:
articles = Article.objects.select_related('category').prefetch_related('tags')
for article in articles:
    print(article.title)  # Все книги загружены заранее, один запрос к базе данных для category и несколько для tags
Когда использовать ленивую загрузку
Простые запросы: Когда вы знаете, что связанные данные будут загружаться редко или только для небольшого числа объектов.
Малые наборы данных: Когда работаете с небольшими наборами данных, где дополнительные запросы не будут существенно влиять на производительность.
Прототипирование: На этапе разработки и тестирования, когда производительность не является критичной.
Когда использовать жадную загрузку
Сложные запросы: Когда вы знаете, что будете часто обращаться к связанным данным, особенно в циклах.
Большие наборы данных: Когда работаете с большими наборами данных, где множество отдельных запросов могут существенно замедлить выполнение.
Производительность: В производственных системах, где производительность критична и необходимо минимизировать количество запросов к базе данных.
Выбор между ленивой и жадной загрузкой зависит от конкретных требований вашего приложения. Ленивая загрузка проще в использовании и может быть достаточной для простых сценариев, тогда как жадная загрузка требует дополнительных настроек, но может значительно повысить производительность в сложных и ресурсоёмких запросах.

commit: Урок 7: включили жадную загрузку